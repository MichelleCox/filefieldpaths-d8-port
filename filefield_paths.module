<?php
/**
 * @file
 * Contains core functions for the File (Field) Paths module.
 */

use Drupal\Core\Url;

//@TODO: Replace the include files.
// The File, Image, and Video include files are implementing
// hook_filefield_paths_field_type_info() on their behalf. That should be
// replaced with a plugin. The other includes should just be integrated into the
// rest of the code.
/**
 * Include additional files.
 */
$dirname = dirname(__FILE__) . "/modules";
$includes = file_scan_directory($dirname, '/.inc$/');
foreach (\Drupal::moduleHandler()->getModuleList() as $module) {
  $module_name = $module->getName();
  if (isset($includes[$file = "{$dirname}/{$module_name}.inc"])) {
    require_once $file;
  }
}

// @TODO: Get additional settings into the new config system.
// In D7, settings added to the form ended up with all the other settings
// in a blob in the field_config_instance table. This seems to happen
// automatically. In D8, fields are entities and the settings are part of the
// new config system and simply adding settings to the form is not enough to
// get them saved.

/**
 * Implements hook_form_alter().
 */
function filefield_paths_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  // This gets a list of all the field types from enabled modules that responded
  // to the hook_filefield_paths_field_type_info() invocation. This hook is
  // currently implemented on behalf of File, Image, and Video in the include
  // files under the "modules" directory.
  $field_types = _filefield_paths_get_field_types();

  if (isset($form['#field']) && in_array($form['#field']->type, array_keys($field_types))) {
    // @TODO: Replace hardcoded entity type.
    // This was hardcoded because I haven't found a way to get the entity
    // type from the form. $form['#entity']->entityTypeId; gets me the bundle,
    // such as "article" rather than "node".
    $entity_type = 'node';

    $entity_info = \Drupal::entityManager()->getDefinition($entity_type);

    // This looks like it is supposed to hold the existing data for the settings
    // but it doesn't work as it is never set. Additionally, it doesn't appear
    // that the native File Field settings are stored in this spot, either.
    // @TODO: Make retrieving settings work once saving them works.
    $settings = isset($form['#field']->settings['filefield_paths']) ? $form['#field']->settings['filefield_paths'] : array();

    // @TODO: Hiding directory field doesn't work.
    // Hide standard File directory field.
    $form['field']['settings']['file_directory']['#states'] = array(
      'visible' => array(
        ':input[name="form[settings][filefield_paths_enabled]"]' => array('checked' => FALSE),
      ),
    );

    $form['field']['settings']['filefield_paths_enabled'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable File (Field) Paths?'),
      '#default_value' => isset($form['#field']->settings['filefield_paths_enabled']) ? $form['#field']->settings['filefield_paths_enabled'] : TRUE,
      '#weight' => 1,
    );

    // File (Field) Paths fieldset element.
    $form['field']['settings']['filefield_paths'] = array(
      '#type' => 'fieldset',
      '#title' => t('File (Field) Path settings'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => 1,
      '#tree' => TRUE,
      '#states' => array(
        'visible' => array(
          ':input[name="field[settings][filefield_paths_enabled]"]' => array('checked' => TRUE),
        ),
      ),
    );

    // Retrieve settings for "File Path" and "File Name" and any others that
    // implement this hook and then add additional settings for each of them.
    // @TODO: Move settings array out of include file.
    $fields = \Drupal::moduleHandler()->invokeAll('filefield_paths_field_settings');
    foreach ($fields as $name => $field) {
      // Attach widget fields.
      $form['field']['settings']['filefield_paths'][$name] = array(
        '#type' => 'container',
      );

      // Attach widget field form elements.
      if (isset($field['form']) && is_array($field['form'])) {
        $token_type_property = 'token type';
        foreach (array_keys($field['form']) as $delta => $key) {
          $form['field']['settings']['filefield_paths'][$name][$key] = array_merge_recursive(
            $field['form'][$key],
            array(
              '#element_validate' => array('token_element_validate'),
              '#token_types' => array('file', $entity_info->$token_type_property),
            )
          );

          // Fetch stored value from instance.
          if (isset($settings[$name][$key])) {
            $form['field']['settings']['filefield_paths'][$name][$key]['#default_value'] = $settings[$name][$key];
          }
        }

        // Field options.
        $form['field']['settings']['filefield_paths'][$name]['options'] = array(
          '#type' => 'fieldset',
          '#title' => t('@title options', array('@title' => t($field['title']))),
          '#collapsible' => TRUE,
          '#collapsed' => TRUE,
          '#weight' => 1,
          '#attributes' => array(
            'class' => array("{$name} cleanup")
          ),
        );

        // @TODO - Make this more modular (this TODO is from D7).
        // Cleanup field with Pathauto module.
        if (\Drupal::moduleHandler()->moduleExists('pathauto')) {
          $pathauto_enabled = TRUE;
          $description = t('Cleanup %title using <a href="@pathauto">Pathauto settings</a>.', array(
            '%title' => t($field['title']),
            '@pathauto' => Url::fromRoute('pathauto.settings.form')));
          $default_value = isset($settings[$name]['options']['pathauto'])
            ? $settings[$name]['options']['pathauto']
            : FALSE;
        }
        else {
          $pathauto_enabled = FALSE;
          $description = t('Pathauto is not installed');
          $default_value = FALSE;
        }

        $form['field']['settings']['filefield_paths'][$name]['options']['pathauto'] = array(
          '#type' => 'checkbox',
          '#title' => t('Cleanup using Pathauto'),
          '#default_value' => $default_value,
          '#description' =>$description,
          '#disabled' => !$pathauto_enabled,
        );

        // Transliterate field with Transliteration module.
        $form['field']['settings']['filefield_paths'][$name]['options']['transliterate'] = array(
          '#type' => 'checkbox',
          '#title' => t('Transliterate'),
          '#default_value' => isset($settings[$name]['options']['transliterate']) && \Drupal::moduleHandler()->moduleExists('transliteration')
            ? $settings[$name]['options']['transliterate']
            : 0,
          '#description' => t('Provides one-way string transliteration (romanization) and cleans the %title during upload by replacing unwanted characters.', array('%title' => t($field['title']))),
          '#disabled' => !\Drupal::moduleHandler()->moduleExists('transliteration'),
        );

        // Replacement patterns for field.
        $form['field']['settings']['filefield_paths']['token_tree'] = array(
          '#type' => 'fieldset',
          '#title' => t('Replacement patterns'),
          '#collapsible' => TRUE,
          '#collapsed' => TRUE,
          // @TODO: _theme does not exist anymore. Find new method of getting token list.
          // '#description' => _theme('token_tree', array('token_types' => array('file', $entity_info['token type']))),
          '#weight' => 10,
        );

        // Retroactive updates.
        $form['field']['settings']['filefield_paths']['retroactive_update'] = array(
          '#type' => 'checkbox',
          '#title' => t('Retroactive update'),
          '#description' => t('Move and rename previously uploaded files.') . '<div>' . t('<strong class="warning">Warning:</strong> This feature should only be used on developmental servers or with extreme caution.') . '</div>',
          '#weight' => 11,
        );

        // Active updating.
        $form['field']['settings']['filefield_paths']['active_updating'] = array(
          '#type' => 'checkbox',
          '#title' => t('Active updating'),
          '#default_value' => isset($settings['active_updating']) ? $settings['active_updating'] : FALSE,
          '#description' => t('Actively move and rename previously uploaded files as required.') . '<div>' . t('<strong class="warning">Warning:</strong> This feature should only be used on developmental servers or with extreme caution.') . '</div>',
          '#weight' => 12
        );
      }
    }

    // @TODO: Uncomment this when retroactive updates are working.
    // $form['#submit'][] = 'filefield_paths_form_submit';
  }
}

/**
 * Submit callback for File (Field) Paths settings form.
 */
function filefield_paths_form_submit($form, &$form_state) {
  // TODO: Make retroactive updates work.
  /*
  // Retroactive updates.
  if ($form_state['values']['instance']['settings']['filefield_paths_enabled'] && $form_state['values']['instance']['settings']['filefield_paths']['retroactive_update']) {
    filefield_paths_batch_update($form_state['values']['instance']);
    batch_process($form_state['redirect']);
  }
  */
}

/**
 * Implements hook_entity_insert().
 */
function filefield_paths_entity_insert($entity, $type) {
  filefield_paths_entity_update($entity, $type);
}

/**
 * Implements hook_entity_update().
 */

// @TODO This entire function needs changing to new Entity Field API.
function filefield_paths_entity_update($entity, $type) {
  $processed = FALSE;
  $field_types = _filefield_paths_get_field_types();
  $entity_info = \Drupal::entityManager()->getDefinition($type);
  $bundle_name = !empty($entity_info['entity keys']['bundle']) ? $entity->{$entity_info['entity keys']['bundle']} : $type;
  if ($entity_info['fieldable']) {

// Fields and field instances are now exportable configuration entities, and
// the Field Info API has been removed.
/// @see https://www.drupal.org/node/2012896
 foreach (field_info_fields($type, $bundle_name) as $field) {
       if (in_array($field['type'], array_keys($field_types))) {
         $files = array();
         $instance = field_info_instance($type, $field['field_name'], $bundle_name);
         $enabled = (isset($instance['settings']['filefield_paths_enabled']) && $instance['settings']['filefield_paths_enabled']) || !isset($instance['settings']['filefield_paths_enabled']);
         if ($enabled && isset($entity->{$field['field_name']})) {
           foreach ($entity->{$field['field_name']} as $langcode => &$deltas) {
             foreach ($deltas as $delta => &$file) {
               // Prepare file.
               if (function_exists($function = "{$field['module']}_field_load")) {
                 $items = array(array(&$file));
                 $function($type, array($entity), $field, array($instance), $langcode, $items, FIELD_LOAD_CURRENT);
               }
               $files[] = &$file;
             }
             // Invoke hook_filefield_paths_process_file().
             foreach (\Drupal::moduleHandler()->getImplementations('filefield_paths_process_file') as $module) {
               if (function_exists($function = "{$module}_filefield_paths_process_file")) {
                 $processed = TRUE;
                 $function($type, $entity, $field, $instance, $langcode, $files);
               }
             }
           }
         }
       }
     }


    if ($processed) {
      $entity->original = isset($entity->original) ? $entity->original : NULL;
      field_attach_update($type, $entity);
    }
  }
}

/**
 * Implements hook_file_presave().
 */
function filefield_paths_file_presave($file) {
  // Store original filename in the database.
  if (empty($file->origname) && isset($file->filename)) {
    $file->origname = $file->filename;
  }
}

/**
 * Run regular expression over all available text-based fields.
 */
function _filefield_paths_replace_path($old, $new, $entity) {
  // Build regular expression.
  $info = parse_url(file_stream_wrapper_uri_normalize($old));
  $info['path'] = !empty($info['path']) ? $info['path'] : '';
  $info['path'] = \Drupal\Component\Utility\UrlHelper::encodePath($info['path']);
  $absolute = str_replace("{$info['host']}{$info['path']}", '', file_create_url($old));
  $relative = parse_url($absolute, PHP_URL_PATH);
  $regex = str_replace('/', '\/', "({$absolute}|{$relative}|{$info['scheme']}://)(styles/([a-z0-9\-_/]*?)/{$info['scheme']}/|)({$info['host']}{$info['path']})");

  // Build replacement.
  $info = parse_url(file_stream_wrapper_uri_normalize($new));
  $info['path'] = !empty($info['path']) ? $info['path'] : '';
  $replacement = "_filefield_paths_replace_path_uri_scheme('\${1}', '{$old}', '{$new}') . '\${2}{$info['host']}{$info['path']}'";

  // Newer versions of the Image module add an 8 character token which is
  // required if the image style hasn't been generated yet. Look for this token
  // in the query string and replace it.
  if (defined('IMAGE_DERIVATIVE_TOKEN')) {
    $regex .= '(\?(\S+?&|)' . IMAGE_DERIVATIVE_TOKEN . '=(\S{8})|)';
    $replacement .= " . _filefield_paths_replace_image_derivative_token('{$old}', '{$new}', '\${5}', '\${7}', '\${3}')";
  }

  // @FIXME
// Fields and field instances are now exportable configuration entities, and
// the Field Info API has been removed.
// 
// 
// @see https://www.drupal.org/node/2012896
// $fields = field_info_fields();

  foreach ($fields as $name => $field) {
    if ($field['module'] == 'text' && isset($entity->{$field['field_name']}) && is_array($entity->{$field['field_name']})) {
      foreach ($entity->{$field['field_name']} as &$language) {
        foreach ($language as &$item) {
          $item['value'] = preg_replace("/$regex/e", $replacement, $item['value']);
          if (isset($item['summary'])) {
            $item['summary'] = preg_replace("/$regex/e", $replacement, $item['summary']);
          }
        }
      }
    }
  }
}

/**
 * Helper function for File (Field) Paths URI updater regular expression.
 *
 * Determines what format the old URI prefix was and returns the new URI prefix
 * in the same format.
 */
function _filefield_paths_replace_path_uri_scheme($prefix, $old, $new) {
  switch (TRUE) {
    case $prefix == file_uri_scheme($old) . '://':
      return file_uri_scheme($new) . '://';

    case $prefix == file_create_url(file_uri_scheme($old) . '://'):
      return file_create_url(file_uri_scheme($new) . '://');

    case $prefix == parse_url(file_create_url(file_uri_scheme($old) . '://'), PHP_URL_PATH):
      return parse_url(file_create_url(file_uri_scheme($new) . '://'), PHP_URL_PATH);
  }

  return $prefix;
}

/**
 * Helper function for File (Field) Paths URI updater regular expression.
 *
 * Replaces the image derivative token at the end of a query string with a new
 * one appropriate for the new file URI.
 */
function _filefield_paths_replace_image_derivative_token($old_uri, $new_uri, $query_string, $token, $style_name) {
  // Only replace the token if the old one was valid.
  if ($query_string && $token && $style_name && $token === image_style_path_token($style_name, $old_uri)) {
    return substr_replace($query_string, image_style_path_token($style_name, $new_uri), -strlen($token));
  }
  return $query_string;
}



/**
 * @param bool $reset
 * @return array
 */
function _filefield_paths_get_field_types($reset = FALSE) {
  $field_types = &drupal_static(__FUNCTION__);

  if (empty($field_types) || $reset) {
    $field_types = \Drupal::moduleHandler()->invokeAll('filefield_paths_field_type_info');
    $field_types = array_flip($field_types);
    foreach (array_keys($field_types) as $type) {
      $info = \Drupal::service('plugin.manager.field.field_type')->getDefinition($type);
      $field_types[$type] = array(
        'label' => $info['label']
      );
    }
  }

  return $field_types;
}

/**
 * Check if a uri is considered local or not.
 *
 * @param string $uri
 *   A file uri.
 *
 * @return
 *   TRUE if the uri is using a local stream wrapper, or FALSE otherwise.
 */
function filefield_paths_uri_is_local($uri) {
  $scheme = file_uri_scheme($uri);
  $wrappers = \Drupal::service("stream_wrapper_manager")->getWrappers(STREAM_WRAPPERS_LOCAL);
  return !empty($wrappers[$scheme]) && empty($wrappers[$scheme]['remote']);
}
