<?php
/**
 * @file
 * Contains core functions for the File (Field) Paths module.
 */

use Drupal\Core\Url;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Config\Entity\ThirdPartySettingsInterface;


//@TODO: Replace the include files.
// The File, Image, and Video include files are implementing
// hook_filefield_paths_field_type_info() on their behalf. That should be
// replaced with a plugin. The other includes should just be integrated into the
// rest of the code.
/**
 * Include additional files.
 */
$dirname = dirname(__FILE__) . "/modules";
$includes = file_scan_directory($dirname, '/.inc$/');
foreach (\Drupal::moduleHandler()->getModuleList() as $module) {
  $module_name = $module->getName();
  if (isset($includes[$file = "{$dirname}/{$module_name}.inc"])) {
    require_once $file;
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for 'field_ui_field_edit_form'.
 */
function filefield_paths_form_field_ui_field_edit_form_alter(array &$form, FormStateInterface $form_state) {
  $field = $form_state->get('field');

  // Get our 3rd party settings to use as defaults on the form.
  $defaults = $field->getThirdPartySettings('filefield_paths');

  // This gets a list of all the field types from enabled modules that responded
  // to the hook_filefield_paths_field_type_info() invocation. This hook is
  // currently implemented on behalf of File, Image, and Video in the include
  // files under the "modules" directory.
  $field_types = _filefield_paths_get_field_types();

  if (isset($field->field_type) && in_array($field->field_type, array_keys($field_types))) {
    // @TODO: Hiding directory field doesn't work.
    // Hide standard File directory field.
    $form['field']['settings']['file_directory']['#states'] = array(
      'visible' => array(
        ':input[name="form[field][third_party_settings][filefield_paths][enabled]"]' => array('checked' => FALSE),
      ),
    );

    // FFP fieldset.
    $form['field']['third_party_settings']['filefield_paths'] = array(
      '#type' => 'details',
      '#title' => t('File (Field) Paths settings'),
      '#open' => TRUE,
    );

    // Enable / disable.
    $form['field']['third_party_settings']['filefield_paths']['enabled'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable File (Field) Paths?'),
      '#default_value' => $defaults['enabled'],
      '#weight' => -10,
    );

    // Token browser.
    $form['field']['third_party_settings']['filefield_paths']['token_tree'] = array(
      '#type' => '#markup',
      '#theme' => 'token_tree_link',
      '#weight' => -5,
    );

    // File path.
    $form['field']['third_party_settings']['filefield_paths']['filepath'] = array(
      '#type' => 'textfield',
      '#title' => t('File path'),
      '#maxlength' => 512,
      '#size' => 128,
      '#element_validate' => array('_file_generic_settings_file_directory_validate'),
      '#default_value' => $defaults['filepath'],
    );

    // File path options fieldset.
    $form['field']['third_party_settings']['filefield_paths']['path_options'] = array(
      '#type' => 'details',
      '#title' => t('File path options'),
      '#open' => FALSE,
    );

    // Clean up path with Pathauto.
    $form['field']['third_party_settings']['filefield_paths']['path_options']['pathauto_path'] = filefield_paths_pathauto_element('filepath', $defaults['path_options']['pathauto_path']);

    // Clean up path with Transliteration
    $form['field']['third_party_settings']['filefield_paths']['path_options']['transliteration_path'] = filefield_paths_transliteration_element('filepath', $defaults['path_options']['transliteration_path']);

    // File name.
    $default = (empty($defaults['filename'])) ? '[file:ffp-name-only-original].[file:ffp-extension-original]' : $defaults['filename'];
    $form['field']['third_party_settings']['filefield_paths']['filename'] = array(
      '#type' => 'textfield',
      '#title' => t('File name'),
      '#maxlength' => 512,
      '#size' => 128,
      '#element_validate' => array('_file_generic_settings_file_directory_validate'),
      '#default_value' => $default,
    );

    // File name options fieldset.
    $form['field']['third_party_settings']['filefield_paths']['name_options'] = array(
      '#type' => 'details',
      '#title' => t('File name options'),
      '#open' => FALSE,
    );

    // Clean up filename with Pathauto.
    $form['field']['third_party_settings']['filefield_paths']['name_options']['pathauto_filename'] = filefield_paths_pathauto_element('filename', $defaults['name_options']['pathauto_filename']);

    // Clean up filename with Transliteration.
    $form['field']['third_party_settings']['filefield_paths']['name_options']['transliteration_filename'] = filefield_paths_transliteration_element('filename', $defaults['name_options']['transliteration_filename']);

    // Retroactive updates.
    $form['field']['third_party_settings']['filefield_paths']['retroactive_update'] = array(
      '#type' => 'checkbox',
      '#title' => t('Retroactive update'),
      '#description' => t('Move and rename previously uploaded files.') . '<div>' . t('<strong class="warning">Warning:</strong> This feature should only be used on developmental servers or with extreme caution.') . '</div>',
      '#weight' => 11,
      '#default_value' => $defaults['retroactive_update'],
    );

    // Active updating.
    $form['field']['third_party_settings']['filefield_paths']['active_updating'] = array(
      '#type' => 'checkbox',
      '#title' => t('Active updating'),
      '#default_value' => $defaults['active_updating'],
      '#description' => t('Actively move and rename previously uploaded files as required.') . '<div>' . t('<strong class="warning">Warning:</strong> This feature should only be used on developmental servers or with extreme caution.') . '</div>',
      '#weight' => 12
    );

    // @TODO: Uncomment this when retroactive updates are working.
    // $form['#submit'][] = 'filefield_paths_form_submit';
  }
}

/**
 * Submit callback for File (Field) Paths settings form.
 */
function filefield_paths_form_submit($form, &$form_state) {
  // TODO: Make retroactive updates work.
  /*
  // Retroactive updates.
  if ($form_state['values']['instance']['settings']['filefield_paths_enabled'] && $form_state['values']['instance']['settings']['filefield_paths']['retroactive_update']) {
    filefield_paths_batch_update($form_state['values']['instance']);
    batch_process($form_state['redirect']);
  }
  */
}

/**
 * Implements hook_entity_insert().
 */
function filefield_paths_entity_insert(EntityInterface $entity) {
  filefield_paths_process_entity($entity);
}

/**
 * Implements hook_entity_update().
 */
function filefield_paths_entity_update(EntityInterface $entity) {
  filefield_paths_process_entity($entity);
}

function filefield_paths_process_entity(EntityInterface $entity) {
  if ($entity instanceof ContentEntityInterface) {
    // Get a list of the types of fields that have files. (File, integer, video)
    $field_types = _filefield_paths_get_field_types();

    // Get a list of the fields on this entity.
    $fields = $entity->getFields();

    // Iterate through all the fields looking for ones in our list.
    foreach ($fields as $key => $field) {
      // Get the field definition which holds the type and our settings.
      $field_info = $field->getFieldDefinition();

      // Get the field type, ie: file.
      $field_type = $field_info->getType();

      // Check the field type against our list of fields.
      if (isset($field_type) && in_array($field_type, array_keys($field_types))) {
        if ($field_info instanceof ThirdPartySettingsInterface) {
          // Retrieve the settings we added to the field.
          $ffp_settings = $field_info->getThirdPartySettings('filefield_paths');

          // If FFP is enabled on this field, process it.
          if ($ffp_settings['enabled']) {

            // Get the machine name of the field.
            $field_name = $field_info->field_name;

            // Go through each item on the field.
            foreach ($entity->{$field_name} as $item) {
              // Get the file entity associated with the item.
              // @TODO: This is necessary with image fields. Check other field types.
              $file_entity = $item->entity;

              // Process the file.
              filefield_paths_process_file($entity, $ffp_settings, $file_entity);
            }
          }
        }
      }
    }
  }
}

// @TODO: Make a FileFieldPathsManager service.
// This service would be given the content entity (ie: node), the file entity,
// and the FFP settings for the field. It would contain all the functions
// needed to process and move all the files for a given field.
function filefield_paths_process_file($entity, $ffp_settings, $file_entity) {
  // Get the service which will do the actual processing.
  $ffp_service = \Drupal::service('filefield_paths.process_string');

  // Retrieve the path/name strings with the tokens from settings.
  $path_setting = $ffp_settings['filepath'];
  $name_setting = $ffp_settings['filename'];

  // Replace tokens.
  // @TODO: Make this work for more than node and file tokens.
  // We need some way of determining what entities are needed to send the
  // proper data in for the Token service to work.
  // Perform token replacement.
  $data = array('node' => $entity, 'file' => $file_entity);
  $new_path = $ffp_service->tokenReplace($path_setting, $data);
  $new_name = $ffp_service->tokenReplace($name_setting, $data);

  // Clean with PathAuto.
  if (!$ffp_settings['path_options']['pathauto_path']) {
    $path_segments = explode("/", $new_path);
    $cleaned_segments = array();
    foreach ($path_segments as $segment) {
      $cleaned_segments[] = $ffp_service->pathAutoClean($segment);
    }
    $new_path = implode("/", $cleaned_segments);
  }

  if (!$ffp_settings['name_options']['pathauto_filename']) {
    $name_parts = pathinfo($new_name);
    $cleaned_base = $ffp_service->pathAutoClean($name_parts['filename']);
    $cleaned_extension = $ffp_service->pathAutoClean($name_parts['extension']);

    $new_name = $cleaned_base . '.' . $cleaned_extension;
  }

  // Transliterate.
  // @TODO: Make transliteration work.
  if (!$ffp_settings['name_options']['transliterate_path']) {
  }
  if (!$ffp_settings['name_options']['transliterate_filename']) {
  }

  // @TODO: This is failing on the directory creation with permission denied.
  file_prepare_directory($new_path, FILE_CREATE_DIRECTORY);
  file_move($file_entity, 'public://' . $new_path . '/' . $new_name);
}

// @TODO: Remove this once it's replaced with the new processing code.
// This is the original function that is in the process of being absorbed into
// function filefield_paths_process_field().
/**
 * Implements hook_filefield_paths_process_file().
 */
function filefield_paths_filefield_paths_process_file($type, $entity, $field, $instance, $langcode, &$items) {
  if (isset($instance['settings']['filefield_paths'])) {
    $settings = $instance['settings']['filefield_paths'];
    foreach ($items as &$file) {
      if (filefield_paths_uri_is_local($file['uri']) && ($file['timestamp'] == REQUEST_TIME || $settings['active_updating'])) {
        $token_data = array(
          'file' => (object) $file,
          $type => $entity
        );

        // Copy the original file for comparison purposes.
        $old_file = $file;

        // Process filename.
        $settings['file_name']['options']['context'] = 'file_name';
        $file['filename'] = !empty($settings['file_name']['value'])
          ? filefield_paths_process_string($settings['file_name']['value'], $token_data, $settings['file_name']['options'])
          : $file['filename'];

        // Process filepath.
        $settings['file_path']['options']['context'] = 'file_path';
        $file['uri'] = "{$field['settings']['uri_scheme']}://" . ltrim(filefield_paths_process_string($settings['file_path']['value'], $token_data, $settings['file_path']['options']) . "/{$file['filename']}", '/');

        // Finalize file if necessary.
        if ($file !== $old_file) {
          $dirname = drupal_dirname($file['uri']);
          if (file_prepare_directory($dirname, FILE_CREATE_DIRECTORY) && file_move((object) $old_file, $file['uri'])) {
            // Process regular expression.
            _filefield_paths_replace_path($old_file['uri'], $file['uri'], $entity);

            // Remove any old empty directories.
            $scheme = file_uri_scheme($old_file['uri']);
            $paths = explode('/', str_replace("{$scheme}://", '', drupal_dirname($old_file['uri'])));
            while ($paths) {
              if (@drupal_rmdir("{$scheme}://" . implode('/', $paths)) == TRUE) {
                array_pop($paths);
                continue;
              }
              break;
            }
          }
        }
      }
    }
  }
}

/**
 * Implements hook_file_presave().
 */
function filefield_paths_file_presave($file) {
  // @TODO: Original code kept for reference until it is absorbed.
  // Store original filename in the database.
  if (empty($file->origname) && isset($file->filename)) {
    $file->origname = $file->filename;
  }
}

/**
 * Returns the form element for the PathAuto checkbox in FFP settings.
 *
 * @param $setting
 *   File path or File name.
 * @param $default
 *   Default or existing value for the form element.
 * @return array
 */
function filefield_paths_pathauto_element($setting, $default) {
  if (\Drupal::moduleHandler()->moduleExists('pathauto')) {
    $pathauto_enabled = TRUE;
    $description = t('Cleanup %setting using <a href="@pathauto">Pathauto settings</a>.', array(
      '%setting' => $setting,
      '@pathauto' => Url::fromRoute('pathauto.settings.form')));
    $default_value = $default;
  }
  else {
    $pathauto_enabled = FALSE;
    $description = t('Pathauto is not installed');
    $default_value = FALSE;
  }

  return array(
    '#type' => 'checkbox',
    '#title' => t('Cleanup using Pathauto'),
    '#default_value' => $default_value,
    '#description' => $description,
    '#disabled' => !$pathauto_enabled,
  );
}

/**
 * Returns the form element for the Transliteration checkbox in FFP settings.
 *
 * @param $setting
 *   File path or File name.
 * @param $default
 *   Default or existing value for the form element.
 * @return array
 */
function filefield_paths_transliteration_element($setting, $default) {
  if (\Drupal::moduleHandler()->moduleExists('transliteration')) {
    $transliteration_enabled = TRUE;
    $description = t('Provides one-way string transliteration (romanization) and cleans the %setting during upload by replacing unwanted characters.', array('%setting' => $setting));
    $default_value = $default;
  }
  else {
    $transliteration_enabled = FALSE;
    $description = t('Transliteration is not installed');
    $default_value = FALSE;
  }

  return array(
    '#type' => 'checkbox',
    '#title' => t('Cleanup using Transliteration'),
    '#default_value' => $default_value,
    '#description' => $description,
    '#disabled' => !$transliteration_enabled,
  );
}

/**
 * Run regular expression over all available text-based fields.
 */
function _filefield_paths_replace_path($old, $new, $entity) {
  // @TODO: Original code kept for reference until it is absorbed.

  // Build regular expression.
  $info = parse_url(file_stream_wrapper_uri_normalize($old));
  $info['path'] = !empty($info['path']) ? $info['path'] : '';
  $info['path'] = \Drupal\Component\Utility\UrlHelper::encodePath($info['path']);
  $absolute = str_replace("{$info['host']}{$info['path']}", '', file_create_url($old));
  $relative = parse_url($absolute, PHP_URL_PATH);
  $regex = str_replace('/', '\/', "({$absolute}|{$relative}|{$info['scheme']}://)(styles/([a-z0-9\-_/]*?)/{$info['scheme']}/|)({$info['host']}{$info['path']})");

  // Build replacement.
  $info = parse_url(file_stream_wrapper_uri_normalize($new));
  $info['path'] = !empty($info['path']) ? $info['path'] : '';
  $replacement = "_filefield_paths_replace_path_uri_scheme('\${1}', '{$old}', '{$new}') . '\${2}{$info['host']}{$info['path']}'";

  // Newer versions of the Image module add an 8 character token which is
  // required if the image style hasn't been generated yet. Look for this token
  // in the query string and replace it.
  if (defined('IMAGE_DERIVATIVE_TOKEN')) {
    $regex .= '(\?(\S+?&|)' . IMAGE_DERIVATIVE_TOKEN . '=(\S{8})|)';
    $replacement .= " . _filefield_paths_replace_image_derivative_token('{$old}', '{$new}', '\${5}', '\${7}', '\${3}')";
  }

  // @FIXME
// Fields and field instances are now exportable configuration entities, and
// the Field Info API has been removed.
// 
// 
// @see https://www.drupal.org/node/2012896
// $fields = field_info_fields();

  foreach ($fields as $name => $field) {
    if ($field['module'] == 'text' && isset($entity->{$field['field_name']}) && is_array($entity->{$field['field_name']})) {
      foreach ($entity->{$field['field_name']} as &$language) {
        foreach ($language as &$item) {
          $item['value'] = preg_replace("/$regex/e", $replacement, $item['value']);
          if (isset($item['summary'])) {
            $item['summary'] = preg_replace("/$regex/e", $replacement, $item['summary']);
          }
        }
      }
    }
  }
}

/**
 * Helper function for File (Field) Paths URI updater regular expression.
 *
 * Determines what format the old URI prefix was and returns the new URI prefix
 * in the same format.
 */
function _filefield_paths_replace_path_uri_scheme($prefix, $old, $new) {
  // @TODO: Original code kept for reference until it is absorbed.
  switch (TRUE) {
    case $prefix == file_uri_scheme($old) . '://':
      return file_uri_scheme($new) . '://';

    case $prefix == file_create_url(file_uri_scheme($old) . '://'):
      return file_create_url(file_uri_scheme($new) . '://');

    case $prefix == parse_url(file_create_url(file_uri_scheme($old) . '://'), PHP_URL_PATH):
      return parse_url(file_create_url(file_uri_scheme($new) . '://'), PHP_URL_PATH);
  }

  return $prefix;
}

/**
 * Helper function for File (Field) Paths URI updater regular expression.
 *
 * Replaces the image derivative token at the end of a query string with a new
 * one appropriate for the new file URI.
 */
function _filefield_paths_replace_image_derivative_token($old_uri, $new_uri, $query_string, $token, $style_name) {
  // @TODO: Original code kept for reference until it is absorbed.
  // Only replace the token if the old one was valid.
  if ($query_string && $token && $style_name && $token === image_style_path_token($style_name, $old_uri)) {
    return substr_replace($query_string, image_style_path_token($style_name, $new_uri), -strlen($token));
  }
  return $query_string;
}



/**
 * @param bool $reset
 * @return array
 */
function _filefield_paths_get_field_types($reset = FALSE) {
  // @TODO: Original code kept for reference until it is absorbed.
  $field_types = &drupal_static(__FUNCTION__);

  if (empty($field_types) || $reset) {
    $field_types = \Drupal::moduleHandler()->invokeAll('filefield_paths_field_type_info');
    $field_types = array_flip($field_types);
    foreach (array_keys($field_types) as $type) {
      $info = \Drupal::service('plugin.manager.field.field_type')->getDefinition($type);
      $field_types[$type] = array(
        'label' => $info['label']
      );
    }
  }

  return $field_types;
}

/**
 * Check if a uri is considered local or not.
 *
 * @param string $uri
 *   A file uri.
 *
 * @return
 *   TRUE if the uri is using a local stream wrapper, or FALSE otherwise.
 */
function filefield_paths_uri_is_local($uri) {
  // @TODO: Original code kept for reference until it is absorbed.
  $scheme = file_uri_scheme($uri);
  $wrappers = \Drupal::service("stream_wrapper_manager")->getWrappers(STREAM_WRAPPERS_LOCAL);
  return !empty($wrappers[$scheme]) && empty($wrappers[$scheme]['remote']);
}
